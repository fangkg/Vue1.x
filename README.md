数据响应式拦截:
    普通对象
    数组

数据响应式更新:
    依赖收集:
        Dep
        Watcher

    编译器:
        文本节点
        v-on:click
        v-bind
        v-model

数据响应式:
Vue 数据响应式的核心原理是 Object.defineProperty。
通过递归遍历整个 data 对象，为对象中的每个 key 设置一个 getter、setter。如果 key 为数组，则走数组响应式的流程。
数组响应式是通过 Object.defineProperty 去拦截数组的七个方法实现的。首先增强了那个七个方法，在完成方法本职工作的基础上增加了依赖通知更新的能力，而且如果有新增数据，则新数据也会被进行响应式处理。
数据响应式更新的能力是通过数据响应式拦截结合 Dep、Watcher、编译器来实现的。
当做完数据初始化工作以后（即响应式拦截），就进入挂载阶段，开始编译整棵 DOM 树，编译过程中 碰到响应式数据，实例化 Watcher，这时会发生数据读取操作，触发 getter，进行依赖收集，将 Watcher 实例放到当前响应式属性对应的 dep 中。
待将来响应式数据更新时，触发 setter，然后触发 dep 通知自己收集的所有 Watcher 实例去执行 update 方法，触发回调函数的执行，从而更新 DOM。


Vue1.x 响应式原理的设计：
Vue1.x 解决工作上的痛点而实现，各种 DOM 操作太繁琐了，初始化时需要通过 DOM 操作将数据设置到节点上，还要监听 DOM 操作，当 DOM 更新时，更新相应的数据。于是就想着能不能把这个过程自动化，这就产生了 Vue1.x。
Vue1.x 的实现其实就很合理了，确实达到了预期的目标。通过 Object.defineProperty 拦截数据的读取和设置，页面初次渲染时，通过编译器编译整棵 DOM 树，给 DOM 节点设置初始值，当 DOM 节点更新时又自动更新了响应式数据，或者响应式数据更新时，通过 Watcher 自动更新对应的 DOM 节点。
这个时候的 Vue 在完成中小型 Web 系统是没有任何问题的。而且相比于 Vue 2.x 性能会更好，因为响应式数据更新时，Watcher 可以直接更新对应的 DOM 节点，没有 2.x 的 VNode 开销和 Diff 过程。
但是大型 Web 系统就搞不定了，理由也很简单，也是因为它的设计。因为 Vue1.x 中 Watcher 和 模版中响应式数据是 一一对应 关系，也就是说页面中每引用一次响应式数据，就会产生一个 Watcher。在大型系统中，一个页面的数据量可能是非常大的，那就会产生大量的 Watcher，占用大量资源，导致性能下降。
所以一句话总结就是，Vue1.x 在中小型系统中性能会很好，定向更新 DOM 节点，但是大型系统由于 Watcher 太多，导致资源占用过多，性能下降。
